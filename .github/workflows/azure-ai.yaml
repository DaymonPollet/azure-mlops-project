name: Azure ML Job Pipeline # Display name for your workflow in GitHub Actions
on:
  workflow_dispatch: # Allows you to manually trigger the workflow from GitHub UI
  # Uncomment the following block later if you want the workflow to run on every push to 'main'
  # push:
  #   branches:
  #     - main

env:
  GROUP: mlops-demo 
  WORKSPACE: pollet-daymon-ml 
  LOCATION: westeurope 

jobs:
  azure-pipeline:
    runs-on: ubuntu-24.04 
    steps:
      # 1. Check out code repository: Clones your GitHub repository into the runner
      - name: Check out code repository
        uses: actions/checkout@v4

      # 2. Azure login: Logs into Azure using the Service Principal credentials stored in GitHub Secrets
      - name: Azure login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      # 3. Azure test - Get Compute: (Demonstration step)
      #    Installs Azure ML CLI extension and lists computes to verify connection
      #    This step is directly from your assignment instructions.
      - name: Azure test - Get Compute
        uses: azure/CLI@v2.1.0
        with:
          azcliversion: latest # CHANGED THIS LINE
          inlineScript: |
            az extension add --name ml
            az configure --defaults group=$GROUP workspace=$WORKSPACE location=$LOCATION
            az ml compute list
            
      # 4. Azure -- Component Setup (from assignment)
      # Reusing 'latest' for azcliversion
      - name: Azure -- Component Setup
        uses: Azure/CLI@v2.1.0
        with:
          azcliversion: latest
          inlineScript: |
            az extension add --name ml
            az configure --defaults group=$GROUP workspace=$WORKSPACE location=$LOCATION
            az ml component create --file ./components/dataprep/dataprep.yaml # Corrected from components to component, if you get an error revert to components
            az ml component create --file ./components/dataprep/data_split.yaml # Corrected from components to component
            az ml component create --file ./components/training/training.yaml # Corrected from components to component

      # 5. Pipeline in Azure - Start the training job (from assignment)
      # Reusing 'latest' for azcliversion
      - name: Azure -- Start Training Job
        uses: Azure/CLI@v2.1.0
        with:
          azcliversion: latest
          inlineScript: |
            az extension add --name ml
            az configure --defaults group=$GROUP workspace=$WORKSPACE location=$LOCATION
            az ml job create --file ./pipeline.yaml --stream --set name=animals-classification-${{ github.sha }}-${{ github.run_id }}

      # 6. Stop the compute machine (from assignment)
      # Reusing 'latest' for azcliversion and adding continue-on-error
      - name: Azure -- Stop Compute
        uses: Azure/CLI@v2.1.0
        with:
          azcliversion: latest
          inlineScript: |
            az extension add --name ml -y # Added -y for non-interactive
            az configure --defaults group=$GROUP workspace=$WORKSPACE location=$LOCATION
            az ml compute stop --name cli-created-machine
        continue-on-error: true # Ignore errors if compute is already stopped

  download:
    needs: azure-pipeline
    runs-on: ubuntu-24.04
    outputs:
      model_version: ${{ steps.download_model_version.outputs.MODEL_VERSION }} 
    steps:

      - name: Check out repository
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Azure -- Download Model
        id: download_model_version 
        uses: azure/CLI@v2.1.0
        with:
          azcliversion: latest
          inlineScript: |
            az extension add --name ml -y
            az configure --defaults group=$GROUP workspace=$WORKSPACE location=$LOCATION
            VERSION=$(az ml model list -n animal-classification --query "[0].version" -o tsv)
            echo "MODEL_VERSION=$VERSION" >> $GITHUB_OUTPUT # <--- NEW: Set the variable as a step output
            az ml model download --name animal-classification --version $VERSION

      # New!! Uploads the content of the 'inference' directory as an artifact
      - name: Docker -- Upload API code from Inference
        uses: actions/upload-artifact@v4.3.3
        with:
          name: docker-config
          path: inference

  deploy:
    needs: download # Ensure 'deploy' job depends on 'download'
    runs-on: ubuntu-24.04
    permissions:
      packages: write
      contents: read
    env: # <--- NEW: Define environment variables for the 'deploy' job
      MODEL_VERSION_FOR_K8S: ${{ needs.download.outputs.model_version }} # <--- NEW: Get the output from 'download' job
    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Docker -- Gather Tags
        id: docker-meta-data
        uses: docker/metadata-action@v5.5.1
        with:
          images: |
            ghcr.io/daymonpollet/mlops-animals-api # Ensure this is your GitHub username
          tags: |
            type=ref,event=branch
            type=sha

      - name: Docker -- Login to GHCR
        uses: docker/login-action@v3.2.0
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker -- Download API Code for Inference
        uses: actions/download-artifact@v4.1.7
        with:
          name: docker-config
          path: inference

      - name: Docker Build and push
        id: docker_build
        uses: docker/build-push-action@v5.3.0
        with:
          context: .
          push: true
          tags: ${{ steps.docker-meta-data.outputs.tags }}

      - name: Install kubectl
        run: |
          # Update apt and install necessary packages including gnupg
          sudo apt-get update
          sudo apt-get install -y apt-transport-https ca-certificates curl gnupg

          # Create the directory for apt keyrings if it doesn't exist and set correct permissions
          sudo mkdir -p /etc/apt/keyrings
          sudo chmod 755 /etc/apt/keyrings # Ensure the directory is accessible

          # Download the Kubernetes public key and dearmor it directly to the keyring file.
          # Using 'sudo bash -c' ensures the command runs in a non-interactive shell context.
          curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.29/deb/Release.key | sudo bash -c 'gpg --dearmor > /etc/apt/keyrings/kubernetes-apt-keyring.gpg'

          # Add the Kubernetes apt repository to your sources list
          echo "deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.29/deb/ /" | sudo tee /etc/apt/sources.list.d/kubernetes.list

          # Update apt package index with the new repository
          sudo apt-get update

          # Install kubectl
          sudo apt-get install -y kubectl

      - name: Deploy to Kubernetes
        run: |
          kubectl apply -f k8s-deployment.yaml